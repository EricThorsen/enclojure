package Example;

import java_cup.runtime.*;
import org.enclojure.flex._Lexer;
import java.io.*;
import org.enclojure.flex.*;
import clojure.lang.*;

parser code {:
	public static void main(String args[]) throws Exception {
		if (args.length==0) 
		{
		new ClojureParser(new _Lexer(System.in)).parse();
		}
		else
		{ 
		new ClojureParser(new _Lexer(new java.io.FileInputStream(args[0]))).parse();
		}
	}

:}

terminal NEWLINE
		,WHITESPACE
		,COMMA
		,HEX_DIGIT
		,DIGIT
		,BIG_SUFFIX
		,FLOAT_SUFFIX
		,LONG_SUFFIX
		,INT_SUFFIX
		,DOUBLE_SUFFIX
		,EXPONENT
		,NUM_INT_PART
		,NUM_INT
		,NUM_LONG
		,NUM_BIG_INT
		,NUM_FLOAT
		,NUM_DOUBLE
		,NUM_BIG_DECIMAL
		,LEFT_PAREN 
		,RIGHT_PAREN
		,LEFT_SQUARE
		,RIGHT_SQUARE
		,LEFT_CURLY
		,RIGHT_CURLY
		,SHARP_CURLY
		,QUOTE
		,BACKQUOTE
		,SHARP
		,SHARP_HAT
		,HAT
		,IMPLICIT_ARG
		,TILDA
		,AT
		,TILDAAT
		,ONE_NL
		,CHAR
		,STRING_ESC
		,STRING_CONTENT
		,STRING
		,WRONG_STRING
		,LINE_COMMENT
		,LETTER
		,SLASH_LETTER
		,OTHER
		,NoDigit
		,OTHER_REDUCED
		,NoDigit1
		,IDENT
		,KEYWORD
		,NIL
		,TRUE
		,FALSE
		,BAD_CHARACTER
		,COLON
        ,SYMBOL
		,symDOT
		,symNS_SEP
		,symATOM
		,symIMPLICIT_ARG
		;

terminal INTEGER_LITERAL;
terminal BIG_INT_LITERAL;
terminal LONG_LITERAL;
terminal FLOAT_LITERAL;
terminal DOUBLE_LITERAL;
terminal BIG_DECIMAL_LITERAL;
terminal RATIO;
terminal CHAR_LITERAL;
terminal STRING_LITERAL;
terminal WRONG_STRING_LITERAL;
terminal NULL_LITERAL;

nonterminal Object s_expr;
nonterminal Object expr_part;
nonterminal Object map;
nonterminal Object vector;
nonterminal Object set;
nonterminal Object list;
nonterminal Object empty_list;
nonterminal Object expression;
nonterminal Object literal;
nonterminal Object series,empty;
nonterminal Object atom;
nonterminal Object operands;
nonterminal Object operand;
nonterminal Object symbol;

start with s_expr;	   
	
s_expr ::= expr_part:e
		{: RESULT = e; :}
		;
		
expr_part ::= expr_part:e1 atom:e2
			{:
			if (e1 instanceof IPersistentCollection)
				RESULT = RT.conj((IPersistentCollection)e1,e2);
			RESULT = RT.vector(e1,e2); 
			:} 
  			| atom:e
			{: RESULT = e; :}
			;

series ::= 
	      list:e
		{: RESULT = e; :} 
		| vector:e 
		{: RESULT = e; :}
		| map:e
		{: RESULT = e; :}
		| set:e
		{: RESULT = e; :}
		;
	
operand ::= atom:e
		{:RESULT = e; :}
		;

operands
	::= operands:e1 operand:e2
	{:
	if (e1 instanceof IPersistentCollection)
	{
		System.out.println("operands:conj " + e1 + "," + e2);
		RESULT = RT.conj((IPersistentCollection)e1,e2);
	} else
	{
	System.out.println("operands:vec " + e1 + "," + e2);
	RESULT = RT.vector(e1,e2);
	} 
	:} 
	|   operand:e
		{: 
		System.out.println("operand " + e ); 
		RESULT = e; 
		:}
	;
	
list    ::=  LEFT_PAREN operands:e RIGHT_PAREN
		{: 
		System.out.println("list [" + e +"]");
		RESULT = RT.list (e); 
		:}
		;
		
vector  ::= LEFT_SQUARE operands:e RIGHT_SQUARE
        {:
 		RESULT = RT.vector(e);
		System.out.println("vector [" + e +"]"); 
		:}
        ;

set     ::= SHARP LEFT_CURLY operands:e RIGHT_CURLY
        {: 
		RESULT = RT.set (e); 
		System.out.println("set #{" + e +"}"); 
		:}
        ;

map     ::= LEFT_CURLY operand:e1 operand:e2 RIGHT_CURLY
     	{:
 		RESULT = RT.map(e1,e2);
		System.out.println("map {" + e1 + "," + e2 +"}"); :}
   		;


literal ::= 
       INTEGER_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
 	|  BIG_INT_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
	|  LONG_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
	|  FLOAT_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
	|  DOUBLE_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
	|  BIG_DECIMAL_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
	|  RATIO:e
		{: RESULT = RT.readString((String)e); :}
	|  CHAR_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
	|  STRING_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
	|  WRONG_STRING_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
	|  KEYWORD:e        
		{: RESULT = RT.readString((String)e); :}
	|  NULL_LITERAL:e
		{: RESULT = RT.readString((String)e); :}
	;

symbol ::= symATOM:ns symNS_SEP symATOM:sym
		{:
		RESULT = clojure.lang.Symbol.create((String)ns,(String)sym);
		System.out.println("symbol " + ns + "/" + sym);
		:}
 		| symATOM:sym
		{:
		RESULT = clojure.lang.Symbol.create((String)sym);
		System.out.println("symbol "+ sym);
		:}
		| symDOT:sym
		{:
		RESULT = clojure.lang.Symbol.create((String)sym);
		System.out.println("symbol "+ sym);
		:}
		;

atom ::= series:e
	{: RESULT = e; :}
	| literal:e
	{: RESULT = e; :}
	| symbol:e
	{: RESULT = e; :}	
	;
	
empty ::= /* empty */
    ;

